class e{diff(e,t,n={}){let o;"function"==typeof n?(o=n,n={}):"callback"in n&&(o=n.callback);const s=this.castInput(e,n),l=this.castInput(t,n),r=this.removeEmpty(this.tokenize(s,n)),u=this.removeEmpty(this.tokenize(l,n));return this.diffWithOptionsObj(r,u,n,o)}diffWithOptionsObj(e,t,n,o){var s;const l=e=>(e=this.postProcess(e,n),o?void setTimeout(function(){o(e)},0):e),r=t.length,u=e.length;let i=1,a=r+u;null!=n.maxEditLength&&(a=Math.min(a,n.maxEditLength));const c=null!==(s=n.timeout)&&void 0!==s?s:1/0,h=Date.now()+c,f=[{oldPos:-1,lastComponent:void 0}];let d=this.extractCommon(f[0],t,e,0,n);if(f[0].oldPos+1>=u&&d+1>=r)return l(this.buildValues(f[0].lastComponent,t,e));let g=-1/0,v=1/0;const p=()=>{for(let o=Math.max(g,-i);o<=Math.min(v,i);o+=2){let s;const i=f[o-1],a=f[o+1];i&&(f[o-1]=void 0);let c=!1;if(a){const e=a.oldPos-o;c=a&&0<=e&&e<r}const h=i&&i.oldPos+1<u;if(c||h){if(s=!h||c&&i.oldPos<a.oldPos?this.addToPath(a,!0,!1,0,n):this.addToPath(i,!1,!0,1,n),d=this.extractCommon(s,t,e,o,n),s.oldPos+1>=u&&d+1>=r)return l(this.buildValues(s.lastComponent,t,e))||!0;f[o]=s,s.oldPos+1>=u&&(v=Math.min(v,o-1)),d+1>=r&&(g=Math.max(g,o+1))}else f[o]=void 0}i++};if(o)!function e(){setTimeout(function(){if(i>a||Date.now()>h)return o(void 0);p()||e()},0)}();else for(;i<=a&&Date.now()<=h;){const e=p();if(e)return e}}addToPath(e,t,n,o,s){const l=e.lastComponent;return l&&!s.oneChangePerToken&&l.added===t&&l.removed===n?{oldPos:e.oldPos+o,lastComponent:{count:l.count+1,added:t,removed:n,previousComponent:l.previousComponent}}:{oldPos:e.oldPos+o,lastComponent:{count:1,added:t,removed:n,previousComponent:l}}}extractCommon(e,t,n,o,s){const l=t.length,r=n.length;let u=e.oldPos,i=u-o,a=0;for(;i+1<l&&u+1<r&&this.equals(n[u+1],t[i+1],s);)i++,u++,a++,s.oneChangePerToken&&(e.lastComponent={count:1,previousComponent:e.lastComponent,added:!1,removed:!1});return a&&!s.oneChangePerToken&&(e.lastComponent={count:a,previousComponent:e.lastComponent,added:!1,removed:!1}),e.oldPos=u,i}equals(e,t,n){return n.comparator?n.comparator(e,t):e===t||!!n.ignoreCase&&e.toLowerCase()===t.toLowerCase()}removeEmpty(e){const t=[];for(let n=0;n<e.length;n++)e[n]&&t.push(e[n]);return t}castInput(e,t){return e}tokenize(e,t){return Array.from(e)}join(e){return e.join("")}postProcess(e,t){return e}get useLongestToken(){return!1}buildValues(e,t,n){const o=[];let s;for(;e;)o.push(e),s=e.previousComponent,delete e.previousComponent,e=s;o.reverse();const l=o.length;let r=0,u=0,i=0;for(;r<l;r++){const e=o[r];if(e.removed)e.value=this.join(n.slice(i,i+e.count)),i+=e.count;else{if(!e.added&&this.useLongestToken){let o=t.slice(u,u+e.count);o=o.map(function(e,t){const o=n[i+t];return o.length>e.length?o:e}),e.value=this.join(o)}else e.value=this.join(t.slice(u,u+e.count));u+=e.count,e.added||(i+=e.count)}}return o}}const t=new class extends e{};function n(e,n,o){return t.diff(e,n,o)}function o(e,t){let n;for(n=0;n<e.length&&n<t.length;n++)if(e[n]!=t[n])return e.slice(0,n);return e.slice(0,n)}function s(e,t){let n;if(!e||!t||e[e.length-1]!=t[t.length-1])return"";for(n=0;n<e.length&&n<t.length;n++)if(e[e.length-(n+1)]!=t[t.length-(n+1)])return e.slice(-n);return e.slice(-n)}function l(e,t,n){if(e.slice(0,t.length)!=t)throw Error(`string ${JSON.stringify(e)} doesn't start with prefix ${JSON.stringify(t)}; this is a bug`);return n+e.slice(t.length)}function r(e,t,n){if(!t)return e+n;if(e.slice(-t.length)!=t)throw Error(`string ${JSON.stringify(e)} doesn't end with suffix ${JSON.stringify(t)}; this is a bug`);return e.slice(0,-t.length)+n}function u(e,t){return l(e,t,"")}function i(e,t){return r(e,t,"")}function a(e,t){return t.slice(0,function(e,t){let n=0;e.length>t.length&&(n=e.length-t.length);let o=t.length;e.length<t.length&&(o=e.length);const s=Array(o);let l=0;s[0]=0;for(let r=1;r<o;r++){for(t[r]==t[l]?s[r]=s[l]:s[r]=l;l>0&&t[r]!=t[l];)l=s[l];t[r]==t[l]&&l++}l=0;for(let r=n;r<e.length;r++){for(;l>0&&e[r]!=t[l];)l=s[l];e[r]==t[l]&&l++}return l}(e,t))}function c(e){let t;for(t=e.length-1;t>=0&&e[t].match(/\s/);t--);return e.substring(t+1)}function h(e){const t=e.match(/^\s*/);return t?t[0]:""}const f="a-zA-Z0-9_\\u{C0}-\\u{FF}\\u{D8}-\\u{F6}\\u{F8}-\\u{2C6}\\u{2C8}-\\u{2D7}\\u{2DE}-\\u{2FF}\\u{1E00}-\\u{1EFF}",d=new RegExp(`[${f}]+|\\s+|[^${f}]`,"ug");const g=new class extends e{equals(e,t,n){return n.ignoreCase&&(e=e.toLowerCase(),t=t.toLowerCase()),e.trim()===t.trim()}tokenize(e,t={}){let n;if(t.intlSegmenter){const o=t.intlSegmenter;if("word"!=o.resolvedOptions().granularity)throw new Error('The segmenter passed must have a granularity of "word"');n=Array.from(o.segment(e),e=>e.segment)}else n=e.match(d)||[];const o=[];let s=null;return n.forEach(e=>{/\s/.test(e)?null==s?o.push(e):o.push(o.pop()+e):null!=s&&/\s/.test(s)?o[o.length-1]==s?o.push(o.pop()+e):o.push(s+e):o.push(e),s=e}),o}join(e){return e.map((e,t)=>0==t?e:e.replace(/^\s+/,"")).join("")}postProcess(e,t){if(!e||t.oneChangePerToken)return e;let n=null,o=null,s=null;return e.forEach(e=>{e.added?o=e:e.removed?s=e:((o||s)&&p(n,s,o,e),n=e,o=null,s=null)}),(o||s)&&p(n,s,o,null),e}};function v(e,t,n){return null==(null==n?void 0:n.ignoreWhitespace)||n.ignoreWhitespace?g.diff(e,t,n):function(e,t,n){return m.diff(e,t,n)}(e,t,n)}function p(e,t,n,f){if(t&&n){const a=h(t.value),d=c(t.value),g=h(n.value),v=c(n.value);if(e){const s=o(a,g);e.value=r(e.value,g,s),t.value=u(t.value,s),n.value=u(n.value,s)}if(f){const e=s(d,v);f.value=l(f.value,v,e),t.value=i(t.value,e),n.value=i(n.value,e)}}else if(n){if(e){const e=h(n.value);n.value=n.value.substring(e.length)}if(f){const e=h(f.value);f.value=f.value.substring(e.length)}}else if(e&&f){const n=h(f.value),a=h(t.value),d=c(t.value),g=o(n,a);t.value=u(t.value,g);const v=s(u(n,g),d);t.value=i(t.value,v),f.value=l(f.value,n,v),e.value=r(e.value,n,n.slice(0,n.length-v.length))}else if(f){const e=h(f.value),n=a(c(t.value),e);t.value=i(t.value,n)}else if(e){const n=a(c(e.value),h(t.value));t.value=u(t.value,n)}}const m=new class extends e{tokenize(e){const t=new RegExp(`(\\r?\\n)|[${f}]+|[^\\S\\n\\r]+|[^${f}]`,"ug");return e.match(t)||[]}};const C=new class extends e{constructor(){super(...arguments),this.tokenize=P}equals(e,t,n){return n.ignoreWhitespace?(n.newlineIsToken&&e.includes("\n")||(e=e.trim()),n.newlineIsToken&&t.includes("\n")||(t=t.trim())):n.ignoreNewlineAtEof&&!n.newlineIsToken&&(e.endsWith("\n")&&(e=e.slice(0,-1)),t.endsWith("\n")&&(t=t.slice(0,-1))),super.equals(e,t,n)}};function w(e,t,n){return C.diff(e,t,n)}function P(e,t){t.stripTrailingCr&&(e=e.replace(/\r\n/g,"\n"));const n=[],o=e.split(/(\n|\r\n)/);o[o.length-1]||o.pop();for(let s=0;s<o.length;s++){const e=o[s];s%2&&!t.newlineIsToken?n[n.length-1]+=e:n.push(e)}return n}export{v as a,n as b,w as d};
